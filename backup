import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Configuration, OpenAIApi } from 'openai';
import * as fs from 'fs/promises';
import * as path from 'path';
import { rword } from 'rword';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);

  // generateRandomWords(29000);
  // return;

  const configuration = new Configuration({
    apiKey: process.env.OPENAI_API_KEY,
  });

  const openai = new OpenAIApi(configuration);

  // // 1er test : récupérer les modèles
  // const response = await openai.listModels();
  // console.log(`Found ${response.data.data.length} models`);
  // for (let i = 0; i < response.data.data.length; i++) {
  //   //console.table(response.data.object);
  //   console.table(response.data.data[i]);
  // }

  // lister les fichiers
  const files = await listFiles('src/random_words/');
  //const files = await listFiles('src/input/');
  const embeddings: Array<EmbeddingResult> = [];
  let metadataFileContent = '';

  for (let i = 0; i < files.length; i++) {
    const fileContent = await fs.readFile(files[i], 'utf-8');
    // 3 - get embeddings
    const utf8Sentence = decodeURIComponent(fileContent);
    embeddings.push(await getEmbedding(openai, utf8Sentence, files[i]));
    metadataFileContent += files[i].concat('\n');
    console.log(`API call ${i + 1}/${files.length} DONE!`);
  }

  let vectorFileContent = '';
  for (let i = 0; i < embeddings.length; i++) {
    if (embeddings[i].vector.join('\t').length > 0)
    {
      vectorFileContent += embeddings[i].vector.join('\t').concat('\n');
    } else
    {
      console.warn(`Empty vector for  (attempt ${vectorFileContent}/3.)`);
      
    }
    
  }

  const outputPath = 'src/output/output.tsv';
  const metadataPath = 'src/output/metadata.tsv';
  await fs.writeFile(outputPath, vectorFileContent); // , 'utf-8'
  console.log('Wrote vectors to file', outputPath);
  await fs.writeFile(metadataPath, metadataFileContent);
  console.log('Wrote vectors to file', metadataPath);
}
bootstrap();

interface EmbeddingResult {
  vector: Array<number>;
  file: string;
}

async function getEmbedding(openai: OpenAIApi, utf8Sentence: string, file: string): Promise<EmbeddingResult>
{
  let success = false;
  let nbAttempts = 0;
  let result: EmbeddingResult = null;
  
  while (success === false && nbAttempts < 3)
  {
    nbAttempts += 1;
    try {
      const embedding = await openai.createEmbedding({
        model: 'text-embedding-ada-002',
        input: utf8Sentence,
    });
  
      result = {
        vector: embedding.data.data[0].embedding,
        file: file
      };
    } catch (error) {
      console.error(`There was an error calling openai API (attempt ${nbAttempts}/3.)`);
    }

    success = true;
  }

  return result;
}

async function listFiles(folder: string): Promise<string[]> {
  try {
    const entries = await fs.readdir(folder, { withFileTypes: true });
    const files = entries
      .filter((entry) => entry.isFile())
      .map((entry) => path.join(folder, entry.name));

    //console.log(`Files in "${folder}":`, files);
    return files;
  } catch (err) {
    console.error(`Error listing files in folder "${folder}":`, err);
    throw err;
  }
}

function generateRandomWords(number: number) {
  const wordArray = rword.generate(number);

  // Loop through and generate 30,000 files
  for (const word of wordArray) {
    // Generate a file name for the current word
    const fileName = `src\\random_words\\${word}.txt`;
    // Write the file to disk
    fs.writeFile(fileName, word);
    console.log(`File saved: ${fileName}`);
  }

  console.log(`All files were written successfully(${number})`);
}
